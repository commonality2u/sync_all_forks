# Workflow Name: Appears in the Actions tab
name: Sync Forks and Update README

# Triggers: When the workflow runs
on:
  schedule:
    # Runs every 12 hours (e.g., at 00:15 and 12:15 UTC)
    # See https://crontab.guru/ for help. Adjust as needed.
    # As of May 4, 2025: This schedule is set.
    - cron: '15 */12 * * *'
  workflow_dispatch:
    # Allows manual triggering via the Actions tab
    inputs:
      specific_repo:
        description: 'Specific repository (owner/repo) to sync (leave empty for all forks)'
        required: false
        type: string
      force_sync:
        description: 'Force sync (overwrite fork changes if conflicts) - USE WITH CAUTION!'
        required: false
        type: boolean
        default: false

# Permissions: Define default permissions for the GITHUB_TOKEN for all jobs
# 'contents: write' allows:
# - Pushing changes to THIS repository (for the README update) using GITHUB_TOKEN
# - gh repo sync pushing changes to the FORKS (when using SYNC_TOKEN via env)
permissions:
  contents: write

jobs:
  # ==============================================================
  # Job 1: List Forks and Gather Details
  # ==============================================================
  list-forks:
    name: 1. List Forks & Get Details
    runs-on: ubuntu-latest
    timeout-minutes: 10 # Should be quick
    outputs:
      # Output the list of repo details as a JSON array string
      forks_json: ${{ steps.get_forks.outputs.repos }}
      # Output the count for information and conditional checks
      forks_count: ${{ steps.get_forks.outputs.count }}
    env:
      # Use the dedicated SYNC_TOKEN for listing/viewing forks you own/manage
      GH_TOKEN: ${{ secrets.SYNC_TOKEN }}
      # Inputs from manual trigger
      SPECIFIC_REPO: ${{ github.event.inputs.specific_repo }}
      # Assumes forks are owned by the same entity running the action. Adjust if needed.
      GH_REPO_OWNER: ${{ github.repository_owner }}
    steps:
      - name: Check gh CLI installation
        run: gh --version # Verify gh is available on the runner

      - name: Authenticate gh CLI for Git operations
        run: gh auth setup-git # Ensure git commands gh might invoke use the token

      - name: Get list of forks with details
        id: get_forks
        run: |
          repo_list_json=""
          repo_count=0
          # Define fields to fetch for the README table
          JSON_FIELDS="nameWithOwner,description,parent,primaryLanguage"

          if [[ -n "$SPECIFIC_REPO" ]]; then
            # --- Handle Specific Repo Input ---
            target_repo="$SPECIFIC_REPO"
            echo "Fetching details for specific repository: $target_repo"
            # Prepend owner if not specified in input
            if [[ "$target_repo" != */* ]]; then
              target_repo="$GH_REPO_OWNER/$target_repo"
              echo "Assuming owner: $target_repo"
            fi
            # Fetch details for the single specified repo using 'gh repo view'
            # Use jq to wrap the single object in a JSON array `[ { ... } ]` to match the structure from 'gh repo list'
            repo_list_json=$(gh repo view "$target_repo" --json $JSON_FIELDS | jq --compact-output '[.]')
            # Check if the view command was successful (jq returns non-empty array)
            if [[ -z "$repo_list_json" || "$repo_list_json" == "[null]" ]]; then
               echo "::error::Failed to fetch details for specific repo: $target_repo. Check name and permissions."
               repo_count=0
               repo_list_json="[]"
            else
               repo_count=1
            fi
          else
            # --- Handle Fetching All Forks ---
            echo "Fetching all fork repositories for $GH_REPO_OWNER with details..."
            # Fetch details for all forks using 'gh repo list'
            # Increase --limit if you have > 2000 forks. Note: gh CLI pagination isn't handled here automatically for extreme counts.
            # Using -q '.' outputs the raw JSON array directly.
            repo_list_json=$(gh repo list "$GH_REPO_OWNER" --fork --limit 2000 --json $JSON_FIELDS -q '.')
            repo_count=$(echo "$repo_list_json" | jq 'length')
            echo "Found $repo_count forks."
          fi

          if [[ "$repo_count" -eq 0 ]]; then
             echo "::warning::No repositories found to process."
          fi

          # Output variables for subsequent jobs
          echo "repos=$repo_list_json" >> $GITHUB_OUTPUT
          echo "count=$repo_count" >> $GITHUB_OUTPUT

  # ==============================================================
  # Job 2: Generate README.md
  # ==============================================================
  generate-readme:
    name: 2. Generate README File
    needs: list-forks # Requires the list of forks
    # Only run if forks were actually found
    if: needs.list-forks.outputs.forks_count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Should be enough for checkout, generation, commit, push
    # Permissions needed by the DEFAULT GITHUB_TOKEN to push to THIS repository.
    # Inherited from top-level, but can be specified explicitly.
    # permissions:
    #   contents: write
    steps:
      - name: Checkout Workflow Repo
        uses: actions/checkout@v4
        # No explicit token needed here - uses the default GITHUB_TOKEN
        # which gets 'contents: write' from the top-level permissions block.
        # Ensure no branch protection rules prevent pushes from Actions.

      - name: Generate README content with detailed table
        id: generate
        run: |
          echo "Generating README.md content..."
          JSON_DATA='${{ needs.list-forks.outputs.forks_json }}'
          REPO_COUNT=${{ needs.list-forks.outputs.forks_count }}
          # Dynamically get the path to this workflow file for linking
          WORKFLOW_FILE_PATH=".github/workflows/${{ github.workflow }}"
          GENERATION_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC") # Add timestamp

          TEMP_README=$(mktemp) # Use temp file for safe generation

          # --- README Header ---
          echo "# Synced Fork Repositories" > "$TEMP_README"
          echo "" >> "$TEMP_README"
          echo "This file lists the **$REPO_COUNT** forked repositories managed by the [$WORKFLOW_FILE_PATH]($WORKFLOW_FILE_PATH) workflow." >> "$TEMP_README"
          echo "_Last updated: $GENERATION_DATE_" >> "$TEMP_README"
          echo "" >> "$TEMP_README"

          # --- Table Header ---
          echo "| Repository | Upstream | Language | Description |" >> "$TEMP_README"
          echo "|------------|----------|----------|-------------|" >> "$TEMP_README"

          # --- Table Rows ---
          echo "$JSON_DATA" | jq -c '.[]' | while IFS= read -r repo_obj; do
            # Extract fields using jq, providing defaults for null values
            repo_name=$(echo "$repo_obj" | jq -r '.nameWithOwner // "N/A"')
            repo_link="[$repo_name](https://github.com/$repo_name)"

            upstream_name=$(echo "$repo_obj" | jq -r '.parent.nameWithOwner // "N/A"')
            upstream_link="N/A"
            if [[ "$upstream_name" != "N/A" && "$upstream_name" != "null" ]]; then
               upstream_link="[$upstream_name](https://github.com/$upstream_name)"
            fi

            language=$(echo "$repo_obj" | jq -r '.primaryLanguage.name // "N/A"')
            if [[ "$language" == "null" ]]; then language="N/A"; fi

            description=$(echo "$repo_obj" | jq -r '.description // ""')
            # Escape pipe characters in description to prevent breaking Markdown table
            description=$(echo "$description" | sed 's/|/\\|/g')
            # Optionally truncate long descriptions:
            # description=$(echo "$description" | cut -c 1-150)

            # Append the formatted row to the temp file
            echo "| $repo_link | $upstream_link | $language | $description |" >> "$TEMP_README"
          done

          # Overwrite the actual README.md file
          mv "$TEMP_README" README.md
          echo "README.md generated."

      - name: Commit and Push README if changed
        run: |
          # Configure git user for the commit
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Check if README.md has actual changes staged
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes detected in README.md. Skipping commit."
          else
            echo "Changes detected in README.md. Committing..."
            # Commit changes
            git commit -m "docs: Update list of synced forks (${{ needs.list-forks.outputs.forks_count }} repos)" -m "Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

            echo "Pushing changes..."
            # Retry push with backoff and pull --rebase to handle potential conflicts
            attempt=0
            max_attempts=3
            push_success=false
            while [ $attempt -lt $max_attempts ]; do
              attempt=$((attempt + 1))
              # Attempt push
              if git push; then
                echo "Push successful on attempt $attempt."
                push_success=true
                break
              else
                echo "Push failed on attempt $attempt. Retrying in 15 seconds..."
                sleep 15
                # Pull latest changes before retrying push (use rebase strategy)
                echo "Pulling latest changes..."
                git pull --rebase --autostash # Autostash any local changes (README)
              fi
            done

            if [ "$push_success" = false ]; then
              echo "::error::Failed to push README.md changes after $max_attempts attempts."
              exit 1 # Fail the step if push ultimately fails
            fi
          fi

  # ==============================================================
  # Job 3: Sync Each Fork (Parallel Matrix Job)
  # ==============================================================
  sync-one-fork:
    name: 3. Sync Fork (${{ matrix.repo }})
    needs: list-forks # Requires the list of forks
    # Only run if forks were actually found
    if: needs.list-forks.outputs.forks_count > 0
    runs-on: ubuntu-latest
    # Define the matrix strategy
    strategy:
      fail-fast: false # Allow other matrix jobs to continue even if one fails
      matrix:
        # Create a job instance for each repo from the JSON output
        repo: ${{ fromJson(needs.list-forks.outputs.forks_json) }}
    # Timeout per individual fork sync job
    timeout-minutes: 20 # Allow more time for large repos or slow networks
    env:
      # Use the SYNC_TOKEN with permissions for the FORKED repositories
      GH_TOKEN: ${{ secrets.SYNC_TOKEN }}
      # Inputs from manual trigger
      FORCE_SYNC: ${{ github.event.inputs.force_sync }}
      # The specific owner/repo for this matrix job instance
      REPO_NAME: ${{ matrix.repo.nameWithOwner }} # Extract name from the object

    steps:
      - name: Check gh CLI installation
        run: gh --version

      # Git user config isn't strictly needed for `gh repo sync` but good practice
      - name: Configure Git User (Optional)
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Authenticate gh CLI for Git operations
        run: gh auth setup-git

      - name: Sync Fork (${{ env.REPO_NAME }}) with Retries
        run: |
          attempt=0
          max_attempts=3
          delay=15 # Start with a 15s delay between attempts
          sync_success=false

          # Base command for syncing the current repo in the matrix
          sync_command="gh repo sync ${{ env.REPO_NAME }}"

          # Add --force flag if the workflow input is true
          if [[ "${{ env.FORCE_SYNC }}" == "true" ]]; then
            echo "::warning::Force Sync enabled for ${{ env.REPO_NAME }}."
            sync_command="$sync_command --force"
          fi

          # Add --branch flag if you need to sync a specific branch:
          # sync_command="$sync_command --branch main" # Example

          echo "Attempting to sync ${{ env.REPO_NAME }}..."

          while [ $attempt -lt $max_attempts ]; do
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Running '$sync_command'"

            # Execute the sync command, capture all output (stdout & stderr) and exit status
            output=$( { $sync_command; } 2>&1 )
            status=$?

            # Check exit status. `gh repo sync` exits 0 on success OR if already in sync.
            if [ $status -eq 0 ]; then
              echo "Sync command finished successfully for ${{ env.REPO_NAME }} (Exit Code: 0)."
              # Log the output which might say "already in sync" or show changes
              echo "Output:"
              echo "$output"
              sync_success=true
              break # Exit retry loop on success
            fi

            # If exit status is non-zero, it's an error
            echo "::warning::Sync attempt $attempt failed for ${{ env.REPO_NAME }} (Exit Code: $status)."
            echo "Output:"
            echo "$output"

            if [ $attempt -ge $max_attempts ]; then
              echo "::error::Failed to sync ${{ env.REPO_NAME }} after $max_attempts attempts."
              break # Exit loop after max attempts
            fi

            echo "Waiting $delay seconds before retry..."
            sleep $delay
            delay=$((delay * 2)) # Exponential backoff for retry delay
          done

          # Update Job Summary and exit with appropriate status for this matrix job
          if [ "$sync_success" = true ]; then
            echo "✅ Successfully processed ${{ env.REPO_NAME }}" >> $GITHUB_STEP_SUMMARY
            exit 0 # Success for this matrix job
          else
            echo "❌ Failed to sync ${{ env.REPO_NAME }}" >> $GITHUB_STEP_SUMMARY
            # Optionally include failure output in summary for easier debugging
            echo "<details><summary>Failure Log (Repo: ${{ env.REPO_NAME }})</summary>" >> $GITHUB_STEP_SUMMARY
            echo "<pre><code>$output</code></pre>" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            exit 1 # Failure for this matrix job
          fi

  # ==============================================================
  # Job 4: Final Summary Job
  # ==============================================================
  sync-summary:
    name: 4. Workflow Summary
    # Depends on the completion of list, readme, and sync jobs
    needs: [list-forks, generate-readme, sync-one-fork]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Crucially, run this even if sync or readme jobs failed/were skipped
    if: always()
    steps:
      - name: Report Overall Status
        run: |
          echo "## Fork Sync & README Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Workflow Run ID: ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- Triggered By: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- Total Forks Found: ${{ needs.list-forks.outputs.forks_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # --- Report on README Job ---
          readme_outcome="${{ needs.generate-readme.result }}"
          readme_status_msg="-"
          # Check if the job was expected to run
          if [[ "${{ needs.list-forks.outputs.forks_count }}" -gt 0 ]]; then
              case "$readme_outcome" in
                success) readme_status_msg="✅ README update job completed successfully.";;
                skipped) readme_status_msg="ℹ️ README update job skipped (likely no changes detected or condition not met).";;
                failure) readme_status_msg="⚠️ README update job failed. Check its logs.";;
                cancelled) readme_status_msg="ℹ️ README update job cancelled.";;
                *) readme_status_msg="ℹ️ README update job status: ${readme_outcome}.";;
              esac
          else
              readme_status_msg="ℹ️ README update job skipped (no forks found)."
          fi
          echo "$readme_status_msg" >> $GITHUB_STEP_SUMMARY

          # --- Report on Sync Matrix Job ---
          matrix_outcome="${{ needs.sync-one-fork.result }}"
          sync_status_msg="-"
          # Check if the job was expected to run
          if [[ "${{ needs.list-forks.outputs.forks_count }}" -gt 0 ]]; then
             case "$matrix_outcome" in
                success) sync_status_msg="✅ Sync job matrix completed successfully (all forks processed).";;
                failure) sync_status_msg="⚠️ Sync job matrix finished with failures. Check logs & summary for details.";;
                cancelled) sync_status_msg="ℹ️ Sync job matrix cancelled.";;
                skipped) sync_status_msg="ℹ️ Sync job matrix skipped.";; # Should not happen if count > 0 unless 'if' condition added later
                *) sync_status_msg="ℹ️ Sync job matrix status: ${matrix_outcome}.";;
             esac
          else
              sync_status_msg="ℹ️ Sync job skipped (no forks found)."
          fi
          echo "$sync_status_msg" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Check the 'Sync Fork (...)' job logs and summary panel for per-repository status.*" >> $GITHUB_STEP_SUMMARY

          # You could add logic here to fail the summary job if critical parts failed,
          # although `if: always()` ensures it runs regardless.
          # if [[ "$matrix_outcome" == "failure" || "$readme_outcome" == "failure" ]]; then
          #   exit 1
          # fi
